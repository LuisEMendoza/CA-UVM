[
  {
    "objectID": "U01.html",
    "href": "U01.html",
    "title": "Unidad 1",
    "section": "",
    "text": "Variable controlada. Cantidad o condición que se mide y controla, básicamente es la salida del sistema.\nSeñal de control. También llamada variable manipulada. Es la cantidad o condición que el controlador modifica para afectar el valor de la variable controlada.\nControlar. Significa medir el valor de la variable controlada del sistema y aplicar la variable manipulada al sistema para corregir o limitar la desviación del valor medido respecto del valor deseado.\nPlantas. Objeto físico o fenómeno que se va a controlar.\nProcesos. Operación o desarrollo natural o artificial progresivamente continuo. Es la operación que se va a controlar.\nSistemas. Combinación de componentes que actúan juntos con un objetivo predeterminado.\nPerturbaciones. Señal que tiende a afectar negativamente el valor de la salida de un sistema. Puede ser interna o externa, siendo una entrada más en el primer caso.\nControl realimentado. Operación que con perturbaciones tiende a reducir la diferencia entre la salida del sistema y alguna entrada de referencia y lo realiza siempre tomando en cuenta esta diferencia. Se aplica a perturbaciones impredecibles ya que las conocidas siempre pueden compensarse.\n\n\n\nPodemos definir la planta real como \\(\\tilde{G}(s)\\), mientras que al modelo matemático que la representa como \\(G(s)\\). La planta real contiene incertidumbre, la cual se denota por \\(\\Delta(s)\\).\nTanto la planta real como la nominal pueden estar relacionadas por un factor multiplicativo\n\\[\n\\tilde{G}(s)=G(s)[1+\\Delta(s)]\n\\]\no por un factor aditivo\n\\[\n\\tilde{G}(s)=G(s)+\\Delta(s)\n\\]\nAl no conocer exactamente el error \\(\\Delta(s)\\) se emplea su estimación \\(W(s)\\), la cual es una función de transferencia escalar tipo\n\\[\n\\|\\Delta(s)\\|_\\infty < \\|W(s)\\|_\\infty = max_{0\\leq \\omega \\leq \\infty}|W(j\\omega)|\n\\]\ndonde \\(\\|W(s)\\|_\\infty\\) es el máximo valor de \\(|W(j\\omega)|\\) para \\(0\\leq\\omega\\leq\\infty\\) y se denomina norma H infinito de \\(W(s)\\).\nUtilizando el teorema de la pequeña ganancia, el proceso de diseño conlleva la determinación del controlador \\(K(s)\\) que satisface\n\\[\n\\left \\|\\frac{W(s)}{1+K(s)G(s)}\\right \\|_\\infty <1\n\\]\nsiendo \\(G(s)\\) la función de transferencia del modelo, \\(K(s)\\) es la función de transferencia del controlador y \\(W(s)\\) se escoge como función de transferencia que aproxima \\(\\Delta(s)\\). En muchos casos se satisfacen más de una desigualdad dependiente de \\(G(s)\\), \\(K(s)\\) y \\(W(s)\\).\nPara garantizar la estabilidad robusta y el comportamiento robusto se requiere satisfacer:\n\\[\n\\left \\|\\frac{W_m(s)K(s)G(s)}{1+K(s)G(s)}\\right \\|_\\infty <1\n\\]\npara estabilidad robusta y\n\\[\n\\left \\|\\frac{W_s(s)}{1+K(s)G(s)}\\right \\|_\\infty <1\n\\]\npara comportamiento robusto.\nEstabilidad robusta. El controlador \\(K(s)\\) garantiza la estabilidad interna de todos los sistemas que conforman la representación de la planta real.\nComportamiento robusto. Comportamiento especificado satisfecho para los sistemas que conforman la planta real representada.\n\n\n\n\n\nPara un sistema descrito mediante una ecuación diferencial lineal e invariante en el tiempo, se define como el cociente entre la transformada de Laplace de la salida (función de respuesta) y la transformada de Laplace de la entrada (función de excitación), suponiendo que todas las condiciones iniciales son \\(0\\).\n\\[G(s)=\\left. \\frac{L(salida)}{L(entrada)} \\right |_0 = \\frac{Y(s)}{X(s)}\\]\nPor lo tanto:\n\\[\nY(s)=G(s)X(s)\n\\]\ny\n\\[\ny(t)=\\int_0^t{x(\\tau)g(t-\\tau)d\\tau}=\\int_0^t{g(\\tau)x(t-\\tau)d\\tau}\n\\]\ndonde\n\\[\ng(t), \\ x(\\tau) =0; \\ t<0\n\\]\n\n\n\n\n\n\nPunto de suma. Indica suma o resta de señales, siendo \\(R_1(s)\\) la señal de referencia y \\(R_2(s)\\) la señal que se suma (o en dado caso, puede restarse).\n\n\n\n\n\nPunto de toma o derivación. Se emplea para indicar que alguna señal sale a diferentes lugares.\n\n\n\n\n\nBloque. Elemento básico que representa la función de transferencia. Tiene un efecto multiplicativo.\n\n\n\n\n\nLazo cerrado. La salida \\(C(s)\\) se realimenta al punto de suma, donde se compara con la entrada de referencia \\(R(s)\\). La salida del bloque \\(C(s)\\) se obtiene multiplicando la función de transferencia \\(G(s)\\) por la entrada al bloque \\(E(s)\\).\n\n\n\n\n\nSabiendo pues que la señal de salida es \\(C(s)=E(s)G(s)\\) y que \\(E(s)=R(s)-C(s)H(s)\\), podemos relacionar la primera con la señal de entrada (en este caso \\(R(s)\\)) de la siguiente manera:\n\\[\nC(s)=G(s)[R(s)-C(s)H(s)]\n\\]\no bien:\n\\[\n\\frac{C(s)}{R(s)}=\\frac{G(s)}{1+G(s)H(s)}\n\\]\nA esto le llamamos la función de transferencia en lazo cerrado.\n\n\n\n\nTomemos un ejemplo presente en el libro de texto Ingeniería de Control Moderna de Ogata. Tenemos dos componentes \\(G_1(s)\\) y \\(G_2(s)\\), los cuales están conectados de tres maneras diferentes: a) en serie, b) paralelo y c) en lazo cerrado, donde\n\\[\nG_1(s)=\\frac{num1}{den1}=\\frac{10}{s^2+2s+10}, \\ G_2(s)=\\frac{num2}{den2}=\\frac{5}{s+5}\n\\]\n\n\n\na) Sistema en cascada\n\n\n\n\n\nb) Sistema en paralelo\n\n\n\n\n\nc) Sistema en lazo cerrado\n\n\nVeamos cómo obtener las funciones resultantes de estos arreglos mediante algunos lenguajes de programación.\n\n\nDe acuerdo a la bibliografía ya mencionada, en MATLAB podemos cargar nuestras funciones de la siguiente manera:\nnum1 = [10];\nden1 = [1 2 10];\nnum2 = [0 5];\nden2 = [1 5];\nNotemos que pide que las escribamos separadas en sus respectivos numerador y denominador. Escribamos el comando para obtener la función de transferencia en cascada:\n[num, den] = series(num1,den1,num2,den2);\nprintsys(num,den)\nLa última instrucción nos debe devolver la respuesta:\n\\[\nFT_{cascada}=\\frac{50}{s^3+7s^2+20s+50}\n\\]\nPara calcular la funci[on de transferencia en paralelo, utilizamos el comando\n[num, den] = parallel(num1,den1,num2,den2);\nprintsys(num,den)\nCuya respuesta debería ser:\n\\[\nFT_{paralelo}=\\frac{5s^2+20s+100}{s^3+7s^2+20s+50}\n\\]\nY para finalizar, el sistema en lazo cerrado\n[num, den] = feedback(num1,den1,num2,den2);\nprintsys(num,den)\nCon la respuesta:\n\\[\nFT_{realimentado}=\\frac{10s+50}{s^3+7s^2+20s+100}\n\\]\n\n\n\nEn SciLab difiere un poco la lógica al momento de definir nuestras funciones, sin embargo parece ser un código más corto. Comenzamos declarando la variable a utilizar \\(s\\):\ns = poly(0,'s')\nEnseguida capturamos nuestras funciones, dando Enter tras terminar cada una:\ns1 = 10 / (s^2 + 2*s + 10)\ns2 = 5 / (s + 5)\nLa función de transferencia en cascada se calcula mediante\ns1 * s2\nObteniendo la respuesta:\n\\[\nFT_{cascada}=\\frac{50}{s^3+7s^2+20s+50}\n\\]\nPara el arreglo en paralelo se introduce\ns1 + s2\nDando como resultado:\n\\[\nFT_{paralelo}=\\frac{5s^2+20s+100}{s^3+7s^2+20s+50}\n\\]\nMientras que para determinar la función de transferencia con lazo cerrado usaremos\ns1 /. s2\nObteniendo:\n\\[\nFT_{realimentado}=\\frac{10s+50}{s^3+7s^2+20s+100}\n\\]\n\n\n\nPara poder utilizar Julia debemos instalar la extensión diseñada para Sistemas de Control, esto lo realizamos con el siguiente comando\nusing Pkg; Pkg.add(\"ControlSystems\")\nEl proceso es algo lento, ya que se deben precompilar los paquetes a instalar. Después de esto, debemos cargar dichos paquetes\nusing ControlSystems\nCuando la carga esté lista, veremos el cursor. Esto nos indica que es posible trabajar con el entorno. Declararemos nuestras funciones escribiendo cada una y dando Enter\nG1 = tf([10],[1, 2, 10])\nG2 = tf([5],[1,5])\nPara poder calcular las funciones de transferencia, utilizaremos los comandos siguientes. Para la configuración en cascada:\nseries(G1, G2)\nPara configuración en paralelo:\nparallel(G1, G2)\nY por último, lazo cerrado:\nfeedback(G1, G2)\nEstos tres comandos arrojan los resultados mostrados a continuación:\n\\[\nFT_{cascada}=\\frac{50}{s^3+7s^2+20s+50} \\\\\n\\]\n\\[\nFT_{paralelo}=\\frac{5s^2+20s+100}{s^3+7s^2+20s+50} \\\\\n\\]\n\\[\nFT_{realimentado}=\\frac{10s+50}{s^3+7s^2+20s+100}\n\\]\n\n\n\nEl trabajo con Python en cuanto a Control de Sistemas es posible, sin embargo requiere cierto tratamiento previo en cuanto a instalación de paquetes. Con el entorno ya instalado, obtenido de la fuente oficial, procedemos a agregar paquetes específicos. En este caso, serán dos:\npip install slycot\npip install control\nEs importante que verifiquemos que slycot esté correctamente instalado con\npython -c \"import slycot\"\nNo debería aparecer error alguno.\nArrancamos el sistema importando la librería instalada\n\nimport control\n\nProcedemos a capturar las funciones para obtener sus correspondientes funciones de transferencia:\n\nG1 = control.tf([10],[1, 2, 10])\nG2 = control.tf([5],[1, 5])\n\nPara obtener dichas funciones de transferencia, introducimos lo siguiente para arreglo en serie:\n\nftseries = control.series(G1, G2)\nprint(ftseries)\n\n\n          50\n-----------------------\ns^3 + 7 s^2 + 20 s + 50\n\n\n\nPara arreglo en paralelo:\n\nftparallel = control.parallel(G1, G2)\nprint(ftparallel)\n\n\n  5 s^2 + 20 s + 100\n-----------------------\ns^3 + 7 s^2 + 20 s + 50\n\n\n\nPara arreglo en lazo cerrado:\n\nftfeedback = control.feedback(G1, G2)\nprint(ftfeedback)\n\n\n       10 s + 50\n------------------------\ns^3 + 7 s^2 + 20 s + 100"
  }
]