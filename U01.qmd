---
title: "Unidad 1"
format: html
editor: visual
---

## Introducción a la Ingeniería de Control {#sec-introducción-a-la-ingeniería-de-control}

### Definiciones {#sec-definiciones}

**Variable controlada.** Cantidad o condición que se mide y controla, básicamente es la salida del sistema.

**Señal de control.** También llamada *variable manipulada*. Es la cantidad o condición que el controlador modifica para afectar el valor de la variable controlada.

**Controlar.** Significa medir el valor de la variable controlada del sistema y aplicar la variable manipulada al sistema para corregir o limitar la desviación del valor medido respecto del valor deseado.

**Plantas.** Objeto físico o fenómeno que se va a controlar.

**Procesos.** Operación o desarrollo natural o artificial progresivamente continuo. Es la operación que se va a controlar.

**Sistemas.** Combinación de componentes que actúan juntos con un objetivo predeterminado.

**Perturbaciones.** Señal que tiende a afectar negativamente el valor de la salida de un sistema. Puede ser interna o externa, siendo una entrada más en el primer caso.

**Control realimentado.** Operación que con perturbaciones tiende a reducir la diferencia entre la salida del sistema y alguna entrada de referencia y lo realiza siempre tomando en cuenta esta diferencia. Se aplica a perturbaciones impredecibles ya que las conocidas siempre pueden compensarse.

### Sistema de Control Robusto {#sistema-de-control-robusto}

Podemos definir la planta real como $\tilde{G}(s)$, mientras que al modelo matemático que la representa como $G(s)$. La planta real contiene incertidumbre, la cual se denota por $\Delta(s)$.

Tanto la planta real como la nominal pueden estar relacionadas por un factor multiplicativo

$$
\tilde{G}(s)=G(s)[1+\Delta(s)]
$$

o por un factor aditivo

$$
\tilde{G}(s)=G(s)+\Delta(s)
$$

Al no conocer exactamente el error $\Delta(s)$ se emplea su estimación $W(s)$, la cual es una función de transferencia escalar tipo

$$
\|\Delta(s)\|_\infty < \|W(s)\|_\infty = max_{0\leq \omega \leq \infty}|W(j\omega)|
$$

donde $\|W(s)\|_\infty$ es el máximo valor de $|W(j\omega)|$ para $0\leq\omega\leq\infty$ y se denomina *norma H infinito* de $W(s)$.

Utilizando el teorema de la pequeña ganancia, el proceso de diseño conlleva la determinación del controlador $K(s)$ que satisface

$$
\left \|\frac{W(s)}{1+K(s)G(s)}\right \|_\infty <1
$$

siendo $G(s)$ la función de transferencia del modelo, $K(s)$ es la función de transferencia del controlador y $W(s)$ se escoge como función de transferencia que aproxima $\Delta(s)$. En muchos casos se satisfacen más de una desigualdad dependiente de $G(s)$, $K(s)$ y $W(s)$.

Para garantizar la estabilidad robusta y el comportamiento robusto se requiere satisfacer:

$$
\left \|\frac{W_m(s)K(s)G(s)}{1+K(s)G(s)}\right \|_\infty <1
$$

para estabilidad robusta y

$$
\left \|\frac{W_s(s)}{1+K(s)G(s)}\right \|_\infty <1
$$

para comportamiento robusto.

**Estabilidad robusta.** El controlador $K(s)$ garantiza la estabilidad interna de todos los sistemas que conforman la representación de la planta real.

**Comportamiento robusto.** Comportamiento especificado satisfecho para los sistemas que conforman la planta real representada.

### Modelado matemático de Sistemas de Control {#modelado-matemático-de-sistemas-de-control}

#### Funciones de transferencia {#funciones-de-transferencia}

Para un sistema descrito mediante una ecuación diferencial lineal e invariante en el tiempo, se define como el cociente entre la transformada de Laplace de la salida (función de respuesta) y la transformada de Laplace de la entrada (función de excitación), suponiendo que todas las condiciones iniciales son $0$.

$$G(s)=\left. \frac{L(salida)}{L(entrada)} \right |_0 = \frac{Y(s)}{X(s)}$$

Por lo tanto:

$$
Y(s)=G(s)X(s)
$$

y

$$
y(t)=\int_0^t{x(\tau)g(t-\tau)d\tau}=\int_0^t{g(\tau)x(t-\tau)d\tau}
$$

donde

$$
g(t), \ x(\tau) =0; \ t<0
$$

### Diagramas de bloques {#diagramas-de-bloques}

#### Elementos básicos {#elementos-básicos}

**Punto de suma**. Indica suma o resta de señales, siendo $R_1(s)$ la señal de referencia y $R_2(s)$ la señal que se suma (o en dado caso, puede restarse).

![](Media/PuntoDeSuma.png){fig-align="center"}

**Punto de toma o derivación**. Se emplea para indicar que alguna señal sale a diferentes lugares.

![](Media/PuntoDeToma.png){fig-align="center"}

**Bloque**. Elemento básico que representa la función de transferencia. Tiene un efecto multiplicativo.

![](Media/Bloque.png){fig-align="center"}

**Lazo cerrado**. La salida $C(s)$ se realimenta al punto de suma, donde se compara con la entrada de referencia $R(s)$. La salida del bloque $C(s)$ se obtiene multiplicando la función de transferencia $G(s)$ por la entrada al bloque $E(s)$.

![](Media/LazoCerrado.png){fig-align="center"}

Sabiendo pues que la señal de salida es $C(s)=E(s)G(s)$ y que $E(s)=R(s)-C(s)H(s)$, podemos relacionar la primera con la señal de entrada (en este caso $R(s)$) de la siguiente manera:

$$
C(s)=G(s)[R(s)-C(s)H(s)]
$$

o bien:

$$
\frac{C(s)}{R(s)}=\frac{G(s)}{1+G(s)H(s)}
$$

A esto le llamamos la *función de transferencia en lazo cerrado*.

### Obtención de funciones de transferencia con lenguajes de programación

Tomemos un ejemplo presente en el libro de texto **Ingeniería de Control Moderna** de Ogata. Tenemos dos componentes $G_1(s)$ y $G_2(s)$, los cuales están conectados de tres maneras diferentes: a) en serie, b) paralelo y c) en lazo cerrado, donde

$$
G_1(s)=\frac{num1}{den1}=\frac{10}{s^2+2s+10}, \ G_2(s)=\frac{num2}{den2}=\frac{5}{s+5}
$$

![a) Sistema en cascada](Media/SistemaEnSerie.png)

![b) Sistema en paralelo](Media/SistemaEnParalelo.png)

![c) Sistema en lazo cerrado](Media/SistemaRealimentado.png)

Veamos cómo obtener las funciones resultantes de estos arreglos mediante algunos lenguajes de programación.

#### MATLAB

De acuerdo a la bibliografía ya mencionada, en MATLAB podemos cargar nuestras funciones de la siguiente manera:

``` matlab
num1 = [10];
den1 = [1 2 10];
num2 = [0 5];
den2 = [1 5];
```

Notemos que pide que las escribamos separadas en sus respectivos numerador y denominador. Escribamos el comando para obtener la función de transferencia en cascada:

``` matlab
[num, den] = series(num1,den1,num2,den2);
printsys(num,den)
```

La última instrucción nos debe devolver la respuesta:

$$
FT_{cascada}=\frac{50}{s^3+7s^2+20s+50}
$$

Para calcular la funci\[on de transferencia en paralelo, utilizamos el comando

``` matlab
[num, den] = parallel(num1,den1,num2,den2);
printsys(num,den)
```

Cuya respuesta debería ser:

$$
FT_{paralelo}=\frac{5s^2+20s+100}{s^3+7s^2+20s+50}
$$

Y para finalizar, el sistema en lazo cerrado

``` matlab
[num, den] = feedback(num1,den1,num2,den2);
printsys(num,den)
```

Con la respuesta:

$$
FT_{realimentado}=\frac{10s+50}{s^3+7s^2+20s+100}
$$

#### SciLab

En SciLab difiere un poco la lógica al momento de definir nuestras funciones, sin embargo parece ser un código más corto. Comenzamos declarando la variable a utilizar $s$:

``` octave
s = poly(0,'s')
```

Enseguida capturamos nuestras funciones, dando *Enter* tras terminar cada una:

``` octave
s1 = 10 / (s^2 + 2*s + 10)
```

``` octave
s2 = 5 / (s + 5)
```

La función de transferencia en cascada se calcula mediante

``` octave
s1 * s2
```

Obteniendo la respuesta:

$$
FT_{cascada}=\frac{50}{s^3+7s^2+20s+50}
$$

Para el arreglo en paralelo se introduce

``` octave
s1 + s2
```

Dando como resultado:

$$
FT_{paralelo}=\frac{5s^2+20s+100}{s^3+7s^2+20s+50}
$$

Mientras que para determinar la función de transferencia con lazo cerrado usaremos

``` octave
s1 /. s2
```

Obteniendo:

$$
FT_{realimentado}=\frac{10s+50}{s^3+7s^2+20s+100}
$$

#### Julia

Para poder utilizar Julia debemos instalar la extensión diseñada para Sistemas de Control, esto lo realizamos con el siguiente comando

``` julia
using Pkg; Pkg.add("ControlSystems")
```

El proceso es algo lento, ya que se deben precompilar los paquetes a instalar. Después de esto, debemos cargar dichos paquetes

``` julia
using ControlSystems
```

Cuando la carga esté lista, veremos el cursor. Esto nos indica que es posible trabajar con el entorno. Declararemos nuestras funciones escribiendo cada una y dando *Enter*

``` julia
G1 = tf([10],[1, 2, 10])
```

``` julia
G2 = tf([5],[1,5])
```
